@inject IMediator _mediator
@inject IJSRuntime _jsRuntime

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;
    private GameManifest _manifest = null!;

    private RoomSprite? _roomSprite;
    private ActorSpriteCollection _actorSprites = new();
    private GameObjectSpriteCollection _objectSprites = new();
    private Walkbox? _walkbox;

    private (Task Task, CancellationTokenSource Cts)? _talkState;
    private (Task Task, CancellationTokenSource Cts)? _walkState;

    private string _protagonistId = string.Empty;
    private bool _playerInputEnabled = true;
    private bool _inDebugMode = false;

    [JSInvokable]
    public bool OnKeyDown(string key)
    {
        switch (key)
        {
            case "d":
                _inDebugMode = !_inDebugMode;
                return true;
            case ".":
            case " ":
                _talkState?.Cts.Cancel();
                return true;
        }

        return false;
    }

    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(OnGameManifestLoadedAsync);
        _mediator.Subscribe<PlayerActionStarted>(OnPlayerActionStartedAsync);
        _mediator.Subscribe<PlayerActionCompleted>(OnPlayerActionCompletedAsync);
        _mediator.Subscribe<ProtagonistChanged>(OnProtagonistChangedAsync);
        _mediator.Subscribe<EnterRoomActionExecuted>(OnEnterRoomActionExecutedAsync);
        _mediator.Subscribe<SayLineActionExecuted>(OnSayLineActionExecutedAsync);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _jsRuntime.InvokeVoidAsync(
                "window.CaptureKeyDown",
                DotNetObjectReference.Create(this));
        }
        base.OnAfterRender(firstRender);
    } 

    private async Task OnGameManifestLoadedAsync(GameManifestLoaded @event)
    {
        var phaser = new PhaserHost(
            @event.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            OnDraw);

        _graphics = await phaser.StartAsync("phaser");
        _manifest = @event.Manifest;
    }

    private Task OnPlayerActionStartedAsync(PlayerActionStarted @event)
    {
        _playerInputEnabled = false;
        return Task.CompletedTask;
    }

    private Task OnPlayerActionCompletedAsync(PlayerActionCompleted @event)
    {
        _playerInputEnabled = true;
        return Task.CompletedTask;
    }

    public Task OnProtagonistChangedAsync(ProtagonistChanged @event)
    {
        _protagonistId = @event.Protagonist.Id;
        return Task.CompletedTask;
    }

    public Task OnEnterRoomActionExecutedAsync(EnterRoomActionExecuted @event)
    {
        try
        {
            _graphics.Pause();

            // If graphics for a room were already loaded, dispose.
            if (_roomSprite is not null)
            {
                _roomSprite.Dispose();
                _roomSprite = null;

                _actorSprites.ClearAndDisposeItems();
                _objectSprites.ClearAndDisposeItems();
            }

            // Create graphics to draw the room.
            _roomSprite = new RoomSprite(
                @event.Room,
                OnRoomPointerDownAsync,
                _manifest.Spec.Sprites[@event.Room.Id],
                _graphics);

            // Update camera bounds to size of room.
            _graphics.SetCameraBounds(
                new Size(_roomSprite.Sprite.Size.Width, _graphics.Height));

            // Add sprites for game objects.48CC1A
            foreach (var gameObject in @event.Room.Objects)
            {
                if (gameObject is Actor actor)
                {
                    var actorSprite = new ActorSprite(
                        actor,
                        _manifest.Spec.Sprites[actor.Id],
                        _graphics,
                        OnGameObjectPointerDownAsync,
                        OnGameObjectPointerOutAsync,
                        OnGameObjectPointerOverAsync);

                    _actorSprites.Add(actorSprite);

                    // When the protagonist actor is added to the room, follow it
                    // with the camera.
                    if (actor.Id == _protagonistId)
                    {
                        _graphics.StartCameraFollow(actorSprite.Sprite);
                    } 
                }
                else
                {
                    var objectSprite = new GameObjectSprite(
                        gameObject,
                        _manifest.Spec.Sprites[gameObject.Id],
                        _graphics,
                        onPointerDown: OnGameObjectPointerDownAsync,
                        onPointerOut: OnGameObjectPointerOutAsync,
                        onPointerOver: OnGameObjectPointerOverAsync);

                    _objectSprites.Add(objectSprite);
                }
            }

            _walkbox = new Walkbox(@event.Room.WalkboxArea);
        }
        finally
        {
            _graphics.Resume();
        }

        return Task.CompletedTask;
    }

    private async Task OnSayLineActionExecutedAsync(SayLineActionExecuted @event)
    {
        if (_actorSprites.TryGetValue(
            @event.Actor.Id,
            out ActorSprite actorSprite))
        {
            var cts = new CancellationTokenSource();
            var task = actorSprite.SayLineAsync(@event.Line, cts.Token);

            _talkState = (task, cts);

            await task;
        }
    }

    private void OnDraw(Point pointerPosition)
    {
        if (_inDebugMode &&
            _walkbox is not null &&
            _actorSprites.TryGetValue(
                _protagonistId,
                out ActorSprite? actorSprite))
        {
            _walkbox.Draw(
                actorSprite.Sprite.Position,
                pointerPosition,
                GetWalkboxExcludedAreas(_protagonistId),
                _graphics);
        }
    }

    private async Task OnRoomPointerDownAsync(Point pointerPosition)
    {
        if (_playerInputEnabled)
        {
            await MoveActor(_protagonistId, pointerPosition);
        }
    }

    private Task OnGameObjectPointerDownAsync(
        GameObject gameObject,
        Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerDown(gameObject));

    private Task OnGameObjectPointerOutAsync(
        GameObject gameObject,
        Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOut(gameObject));

    private Task OnGameObjectPointerOverAsync(
        GameObject gameObject,
        Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOver(gameObject));


    private async Task MoveActor(
        string actorId,
        Point to,
        Direction faceDirection = Direction.Front)
    {
        if (_walkbox is not null && _actorSprites.TryGetValue(
            actorId,
            out ActorSprite? actorSprite))
        {
            var path = _walkbox.FindShortestPath(
                actorSprite.Sprite.Position,
                to,
                GetWalkboxExcludedAreas(actorId));

            if (_walkState.HasValue)
            {
                _walkState.Value.Cts.Cancel();
                await _walkState.Value.Task;
            }

            var cts = new CancellationTokenSource();
            var task = actorSprite.WalkAsync(path, faceDirection, cts.Token);

            _walkState = (task, cts);

            await task;
        }
    }

    // Exclude the areas around the other actors to make sure the given
    // actor doesn't bump into them.
    private IEnumerable<Polygon> GetWalkboxExcludedAreas(string actorId) =>
        _actorSprites
            .Where(actorSprite => actorSprite.GameObject.Id != actorId &&
                actorSprite.GameObject.IsVisible)
            .Select(actorSprite =>
            {
                var position = actorSprite.Sprite.Position;

                return new Polygon(new Point[]
                {
                    new Point(position.X - 50, position.Y - 20),
                    new Point(position.X + 50, position.Y - 20),
                    new Point(position.X + 50, position.Y + 20),
                    new Point(position.X - 50, position.Y + 20)
                });
            });
}