@inject ICustomMediator _mediator
@inject IJSRuntime _jsRuntime
@inject ILoggerFactory _loggerFactory
@implements INotificationHandler<GameManifestLoaded>
@implements INotificationHandler<ProtagonistChanged>
@implements INotificationHandler<RoomEntered>

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;

    private string _protagonistId = string.Empty;

    private RoomGraphics? _roomGraphics;
    private Dictionary<string, ActorGraphics> _actorGraphicsById = new();
    private Walkbox? _walkbox;

    private bool _inDebugMode = false;

    [JSInvokable]
    public bool OnKeyDown(string key)
    {
        switch (key)
        {
            case "d":
                _inDebugMode = !_inDebugMode;
                return true;
        }

        return false;
    }

    public async Task Handle(GameManifestLoaded notification, CancellationToken cancellationToken)
    {
        var phaser = new PhaserHost(
            notification.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            _loggerFactory,
            OnDraw);

        _graphics = await phaser.StartAsync("phaser");
    }

    public Task Handle(ProtagonistChanged notification, CancellationToken cancellationToken)
    {
        _protagonistId = notification.Protagonist.Id;
        return Task.CompletedTask;
    }

    public async Task Handle(RoomEntered notification, CancellationToken cancellationToken)
    {
        try
        {
            //    await graphics!.SetRenderLockAsync(true);

            //            //                    if (this.room != null) {
            //            //                        this.room.kill();
            //            //                    }

            _walkbox = new Walkbox(notification.Room.Walkbox);

            _roomGraphics = RoomGraphics.Create(notification.Room, OnRoomPointerDownAsync, _graphics);

            foreach (var actor in notification.Room.Actors)
            {
                var actorGraphics = ActorGraphics.Create(
                    actor,
                    OnGameObjectPointerOutAsync,
                    OnGameObjectPointerOverAsync,
                    _graphics);


                _actorGraphicsById.Add(actor.Id, actorGraphics);

                // When the protagonist actor is added to the room, follow it
                // with the camera.
                if (actor.Id == _protagonistId)
                {
                    _graphics.StartCameraFollow(actorGraphics.Sprite);
                }
            }

            // TODO Add objects/items


            // Update world bounds to size of room.
            // TODO Actually SetCameraBounds
            _graphics.SetWorldBounds(
                new Size(_roomGraphics.Sprite.Size.Width, _graphics.Height));





            

            //    this.narrator = new Narrator(game, layers);
            //    this.narrator.create();

        }
        finally
        {
            //    await graphics!.SetRenderLockAsync(false);
        }
    }

    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(this);
        _mediator.Subscribe<ProtagonistChanged>(this);
        _mediator.Subscribe<RoomEntered>(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _jsRuntime.InvokeVoidAsync("window.CaptureKeyDown", DotNetObjectReference.Create(this));
        }
        base.OnAfterRender(firstRender);
    }    

    private void OnDraw(Point pointerPosition)
    {
        if (_inDebugMode &&
            _walkbox is not null &&
            _actorGraphicsById.TryGetValue(
                _protagonistId,
                out ActorGraphics? actorGraphics))
        {
            _walkbox.Draw(
                actorGraphics.Sprite.Position,
                pointerPosition,
                GetWalkboxExcludedAreas(_protagonistId),
                _graphics);
        }
    }

    private Task OnRoomPointerDownAsync(Point pointerPosition) =>
        MoveActor(_protagonistId, pointerPosition);

    private async Task MoveActor(string actorId, Point to, Direction faceDirection = Direction.Front)
    {
        if (_walkbox is not null && _actorGraphicsById.TryGetValue(
            actorId,
            out ActorGraphics? actorGraphics))
        {
            var path = _walkbox.FindShortestPath(
                actorGraphics.Sprite.Position,
                to,
                GetWalkboxExcludedAreas(actorId));

            await actorGraphics.WalkAsync(path, faceDirection);
        }
    }

    private Task OnGameObjectPointerOutAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.Publish(new GameObjectPointerOut(gameObject));

    private Task OnGameObjectPointerOverAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.Publish(new GameObjectPointerOver(gameObject));

    // Exclude the areas around the other actors to make sure the given
    // actor doesn't bump into them.
    private IEnumerable<Polygon> GetWalkboxExcludedAreas(string actorId) =>
        _actorGraphicsById
            .Where(entry => entry.Key != actorId &&
                entry.Value.Actor.IsVisible)
            .Select(entry =>
            {
                var position = entry.Value.Sprite.Position;

                return new Polygon(
                    new Point(position.X - 50, position.Y - 20),
                    new Point(position.X + 50, position.Y - 20),
                    new Point(position.X + 50, position.Y + 20),
                    new Point(position.X - 50, position.Y + 20));
            });
}