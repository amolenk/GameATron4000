@inject ICustomMediator _mediator
@inject IJSRuntime _jsRuntime
@inject ILoggerFactory _loggerFactory
@implements INotificationHandler<GameManifestLoaded>
@implements INotificationHandler<ProtagonistChanged>
@implements INotificationHandler<RoomEntered>

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;

    private string _protagonistId = string.Empty;

    private RoomGraphics? _roomGraphics;
    private Dictionary<string, ActorGraphics> _actorGraphicsById = new();
    private Walkbox? _walkbox;

    private bool _inDebugMode = false;

    [JSInvokable]
    public bool OnKeyDown(string key)
    {
        switch (key)
        {
            case "d":
                _inDebugMode = !_inDebugMode;
                return true;
        }

        return false;
    }

    public async Task Handle(GameManifestLoaded notification, CancellationToken cancellationToken)
    {
        var phaser = new PhaserHost(
            notification.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            _loggerFactory,
            OnDraw);

        _graphics = await phaser.StartAsync("phaser");
    }

    public Task Handle(ProtagonistChanged notification, CancellationToken cancellationToken)
    {
        _protagonistId = notification.Protagonist.Id;
        return Task.CompletedTask;
    }

    public async Task Handle(RoomEntered notification, CancellationToken cancellationToken)
    {
        try
        {
            //    await graphics!.SetRenderLockAsync(true);

            //            //                    if (this.room != null) {
            //            //                        this.room.kill();
            //            //                    }

            _roomGraphics = RoomGraphics.Create(notification.Room, OnRoomPointerDownAsync, _graphics);

            foreach (var actor in notification.Room.Actors)
            {
                var actorGraphics = ActorGraphics.Create(
                    actor,
                    OnGameObjectPointerOutAsync,
                    OnGameObjectPointerOverAsync,
                    _graphics);


                _actorGraphicsById.Add(actor.Id, actorGraphics);

                // When the protagonist actor is added to the room, follow it
                // with the camera.
                if (actor.Id == _protagonistId)
                {
                    _graphics.StartCameraFollow(actorGraphics.Sprite);
                }
            }

            // TODO Add objects/items

            _walkbox = new Walkbox(notification.Room.Walkbox);

            // Update world bounds to size of room.
            // TODO Actually SetCameraBounds
            _graphics.SetWorldBounds(
                new Size(_roomGraphics.Sprite.Size.Width, _graphics.Height));





            

            //    this.narrator = new Narrator(game, layers);
            //    this.narrator.create();

        }
        finally
        {
            //    await graphics!.SetRenderLockAsync(false);
        }
    }

    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(this);
        _mediator.Subscribe<ProtagonistChanged>(this);
        _mediator.Subscribe<RoomEntered>(this);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _jsRuntime.InvokeVoidAsync("window.CaptureKeyDown", DotNetObjectReference.Create(this));
        }
        base.OnAfterRender(firstRender);
    }    

    private void OnDraw(Point mousePosition)
    {
        if (_inDebugMode &&
            _walkbox is not null &&
            _actorGraphicsById.TryGetValue(
                _protagonistId,
                out ActorGraphics actorGraphics))
        {
            _walkbox.Draw(
                actorGraphics.Sprite.Position,
                mousePosition,
                GetWalkboxExcludedAreas(),
                _graphics);
        }
    }

    private Task OnRoomPointerDownAsync(Point mousePosition)
    {
        if (_actorGraphicsById.TryGetValue(
            _protagonistId,
            out ActorGraphics actorGraphics))
        {
            var path = _walkbox.FindShortestPath(
                actorGraphics.Sprite.Position,
                mousePosition,
                GetWalkboxExcludedAreas());

            actorGraphics.Walk(path);
        }

        return Task.CompletedTask;


    @* public async moveActor(actorId: string, toX: number, toY: number, faceDirection: string) {
        const actor = this.getActor(actorId);
        const walkbox = this.createWalkbox(actor);
        const path = walkbox.findPath(actor.x, actor.y, toX, toY);
        if (path) {
            path.shift();
            await actor.walkTo(path, faceDirection);
        } else {
            actor.changeDirection(faceDirection);
        } *@


        @*if (this.uiMediator.uiEnabled)
            {
                this.moveActor(this.uiMediator.selectedActor, this.game.input.x + this.game.camera.x, this.game.input.y + this.game.camera.y, "front")
                        }*@

    }

    private Task OnGameObjectPointerOutAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.Publish(new GameObjectPointerOut(gameObject));

    private Task OnGameObjectPointerOverAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.Publish(new GameObjectPointerOver(gameObject));

    // Exclude the areas around the actors to make sure the protagonist
    // doesn't bump into any other actors.
    private IEnumerable<Polygon> GetWalkboxExcludedAreas() =>
        _actorGraphicsById
            .Where(entry => entry.Key != _protagonistId &&
                entry.Value.Actor.IsVisible)
            .Select(entry =>
            {
                var position = entry.Value.Sprite.Position;

                return new Polygon(
                    new Point(position.X - 50, position.Y - 20),
                    new Point(position.X + 50, position.Y - 20),
                    new Point(position.X + 50, position.Y + 20),
                    new Point(position.X - 50, position.Y + 20));
            });
}