@inject ICustomMediator _mediator
@inject IJSRuntime _jsRuntime
@inject ILoggerFactory _loggerFactory
@implements INotificationHandler<GameManifestLoaded>
@implements INotificationHandler<RoomEntered>

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;
    private Walkbox? _walkbox;

    private Actor _actor;

    public async Task Handle(GameManifestLoaded notification, CancellationToken cancellationToken)
    {
        Console.WriteLine("Handle RoomView.GameManifestLoadedEvent!");

        var phaser = new PhaserHost(
            notification.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            _loggerFactory,
            OnUpdate);

        _graphics = await phaser.StartAsync("phaser");
    }

    public async Task Handle(RoomEntered notification, CancellationToken cancellationToken)
    {
        Console.WriteLine("Handle roomEntered!");

        try
        {
            //    await graphics!.SetRenderLockAsync(true);

            //            //                    if (this.room != null) {
            //            //                        this.room.kill();
            //            //                    }

            //            //                    const walkbox = new Phaser.Polygon(
            //            //                        event.room.walkbox.map((p: any) => new Phaser.Point(p.x, p.y)));

            //            //                    this.room = new Room(event.room.id, event.room.scale, walkbox);
            //            //                    this.room.create(this.game, this, this.layers);

            // Add the room background.
            var background = await _graphics.AddSpriteAsync(
                0,
                0,
                $"rooms/{notification.Room.Id}",
                options =>
                {
                    options.SetInteractive();
                    options.SetOrigin(0, 0);
                });

            await background.OnPointerDownAsync(OnBackgroundPointerDownAsync);

            // Update world bounds to size of room.
            await _graphics!.SetWorldBoundsAsync(0, 0, background.Width, _graphics.Height);

            _walkbox = notification.Room.Walkbox;


            @*

                this.narrator = new Narrator(game, layers);
                this.narrator.create();

                this.walkboxPolygons = [];
                this.walkboxPolygons.push(this.walkbox);*@

            foreach (var actor in notification.Actors)
            {
                await AddActorAsync(actor, actor.PositionX, actor.PositionY);
            }

            //            //                    for (let actor of event.actors) {
            //            //                        this.room.addActor(
            //            //                            new Actor(
            //            //                                actor.id,
            //            //                                actor.name,
            //            //                                actor.classes,
            //            //                                actor.usePosition,
            //            //                                actor.useDirection,
            //            //                                actor.faceDirection,
            //            //                                actor.textColor),
            //            //                            actor.x,
            //            //                            actor.y);
            //            //                    }

            //            //                    for (let obj of event.objects) {
            //            //                        this.room.addObject(
            //            //                            new RoomObject(obj.id, obj.name, obj.classes, obj.state, obj.usePosition, obj.useDirection),
            //            //                            obj.x,
            //            //                            obj.y,
            //            //                            obj.z_offset);
            //            //                    }

        }
        finally
        {
            //    await graphics!.SetRenderLockAsync(false);
        }
    }

    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(this);
        _mediator.Subscribe<RoomEntered>(this);
    }

    private Task OnCreateAsync() => Task.CompletedTask;

    private void OnUpdate(Point mousePosition)
    {
        if (_walkbox != null)
        {
            var excludedAreas = new Polygon[]
            {
                @* new Polygon(new Point[]
                {
                    new Point(600, 420),
                    new Point(640, 420),
                    new Point(640, 440),
                    new Point(600, 440),
                }),
                new Polygon(new Point[]
                {
                    new Point(100, 100),
                    new Point(200, 100),
                    new Point(200, 200),
                    new Point(100, 200),
                }) *@
            };

            _walkbox.Draw(_actor.Position, mousePosition, excludedAreas, _graphics);
        }
    }

    private async Task AddActorAsync(ActorTemp actor, int x, int y)
    {
        _actor = await Actor.CreateAsync(actor, _graphics);

        //        this.actors.push(actor);

        // When the player actor is added to the room, follow it
        // with the camera.
        @*if (actor.id == this.uiMediator.selectedActor)
                {
                    //  0.1 is the amount of linear interpolation to use.
                    //  The smaller the value, the smooth the camera (and the longer it takes to catch up)
                    actor.focusCamera(true)
                    }
            }*@
    }

    private async Task OnBackgroundPointerDownAsync(Point mousePosition)
    {
        Console.WriteLine($"Clicked at: {mousePosition}");

        var path = _walkbox.FindShortestPath(
            _actor.Position,
            mousePosition,
            Enumerable.Empty<Polygon>());

        _actor.Walk(path);

    @* public async moveActor(actorId: string, toX: number, toY: number, faceDirection: string) {
        const actor = this.getActor(actorId);
        const walkbox = this.createWalkbox(actor);
        const path = walkbox.findPath(actor.x, actor.y, toX, toY);
        if (path) {
            path.shift();
            await actor.walkTo(path, faceDirection);
        } else {
            actor.changeDirection(faceDirection);
        } *@


        @*if (this.uiMediator.uiEnabled)
            {
                this.moveActor(this.uiMediator.selectedActor, this.game.input.x + this.game.camera.x, this.game.input.y + this.game.camera.y, "front")
                        }*@


        //        return Task.CompletedTask;
    }

}