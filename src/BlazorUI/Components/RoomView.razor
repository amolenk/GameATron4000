@inject IMediator _mediator
@inject IJSRuntime _jsRuntime
@inject ILogger<RoomView> _logger

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;
    private GameManifest _manifest = null!;
    private RoomSprite? _roomSprite;
    private GameObjectSpriteCollection _objectSprites = new();

    private (Task Task, CancellationTokenSource Cts)? _talkState;
    private (Task Task, CancellationTokenSource Cts)? _walkState;

    private string _protagonistId = string.Empty;
    private bool _playerInputEnabled = true;
    private bool _inDebugMode = false;


    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(OnGameManifestLoadedAsync);
        _mediator.Subscribe<PlayerActionStarted>(OnPlayerActionStartedAsync);
        _mediator.Subscribe<PlayerActionCompleted>(OnPlayerActionCompletedAsync);
        _mediator.Subscribe<ProtagonistChanged>(OnProtagonistChangedAsync);
        _mediator.Subscribe<RoomEntered>(OnRoomEnteredAsync);
        _mediator.Subscribe<LineSpoken>(OnLineSpokenAsync);
        _mediator.Subscribe<ActorMoved>(OnActorMovedAsync);
        _mediator.Subscribe<GameObjectPlacedInRoom>(OnGameObjectPlacedInRoomAsync);
        _mediator.Subscribe<GameObjectRemovedFromRoom>(OnGameObjectRemovedFromRoomAsync);
        _mediator.Subscribe<DelayRequested>(OnDelayRequestedAsync);
        _mediator.Subscribe<GameObjectStatusChanged>(OnGameObjectStatusChangedAsync);
        _mediator.Subscribe<DebugModeChanged>(OnDebugModeChangedAsync);
        _mediator.Subscribe<SkipWait>(OnSkipWaitAsync);
    }

    private Task OnDebugModeChangedAsync(DebugModeChanged @event)
    {
        _inDebugMode = @event.DebugEnabled;
        return Task.CompletedTask;
    }

    private Task OnSkipWaitAsync(SkipWait command)
    {
        _talkState?.Cts.Cancel();
        return Task.CompletedTask;
    }

    private async Task OnGameManifestLoadedAsync(GameManifestLoaded @event)
    {
        var phaser = new PhaserHost(
            @event.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            OnDraw);

        _graphics = await phaser.StartAsync("phaser");
        _manifest = @event.Manifest;
    }

    private Task OnPlayerActionStartedAsync(PlayerActionStarted @event)
    {
        _playerInputEnabled = false;
        return Task.CompletedTask;
    }

    private Task OnPlayerActionCompletedAsync(PlayerActionCompleted @event)
    {
        _playerInputEnabled = true;
        return Task.CompletedTask;
    }

    public Task OnProtagonistChangedAsync(ProtagonistChanged @event)
    {
        _protagonistId = @event.Protagonist.Id;
        return Task.CompletedTask;
    }

    private Task OnDelayRequestedAsync(DelayRequested @event) =>
        Task.Delay(@event.Delay);

    public Task OnRoomEnteredAsync(RoomEntered @event)
    {
        using var pauseGraphics = _graphics.Pause();

        // If graphics for a room were already loaded, dispose.
        if (_roomSprite is not null)
        {
            _roomSprite.Dispose();
            _roomSprite = null;

            _objectSprites.ClearAndDisposeItems();
        }

        // Create graphics to draw the room.
        _roomSprite = new RoomSprite(
            @event.Room,
            OnRoomPointerDownAsync,
            _manifest.Spec.Sprites,
            _graphics);

        // Update camera bounds to size of room.
        _graphics.SetCameraBounds(
            new Size(_roomSprite.Sprite.Size.Width, _graphics.Height));

        // Add sprites for game objects.
        foreach (var gameObject in @event.VisibleObjects)
        {
            AddGameObjectSprite(gameObject);
        }
 
        return Task.CompletedTask;
    }

    private Task OnGameObjectStatusChangedAsync(GameObjectStatusChanged @event)
    {
        using var pauseGraphics = _graphics.Pause();

        if (_objectSprites.TryGetValue(
            @event.GameObject.Id, out GameObjectSprite objectSprite))
        {
            // TODO Refresh is better name than Reset
            objectSprite.ResetSpriteFrame();
        }

        foreach (var objectToShow in @event.ObjectsToShow)
        {
            AddGameObjectSprite(objectToShow);
        }

        foreach (var objectsToHide in @event.ObjectsToHide)
        {
            RemoveGameObjectSprite(objectsToHide);
        }

        return Task.CompletedTask;
    }

    private async Task OnLineSpokenAsync(LineSpoken @event)
    {
        if (TryGetActorSprite(@event.Actor.Id, out ActorSprite actorSprite))
        {
            var cts = new CancellationTokenSource();
            var task = actorSprite.SayLineAsync(@event.Line, cts.Token);

            _talkState = (task, cts);

            await task;
        }
    }

    private Task OnActorMovedAsync(ActorMoved @event) =>
        MoveActor(@event.Actor.Id, @event.Position, @event.Status);

    private Task OnGameObjectPlacedInRoomAsync(GameObjectPlacedInRoom @event)
    {
        if (_roomSprite?.Room == @event.Room)
        {
            AddGameObjectSprite(@event.GameObject);
        }

        return Task.CompletedTask;
    }

    private Task OnGameObjectRemovedFromRoomAsync(GameObjectRemovedFromRoom @event)
    {
        if (_roomSprite?.Room == @event.Room)
        {
            RemoveGameObjectSprite(@event.GameObject);
        }

        return Task.CompletedTask;
    }

    private void AddGameObjectSprite(GameObject gameObject)
    {
        _logger.LogDebug($"Adding sprite for object '{gameObject.Id}({gameObject.Status})' at {gameObject.Position}");

        if (gameObject is Actor actor)
        {
            var actorSprite = new ActorSprite(
                actor,
                _manifest.Spec.Sprites,
                _graphics,
                OnGameObjectPointerDownAsync,
                OnGameObjectPointerOutAsync,
                OnGameObjectPointerOverAsync);

            _objectSprites.Add(actorSprite);

            // When the protagonist actor is added to the room, follow it
            // with the camera.
            if (actor.Id == _protagonistId)
            {
                _graphics.StartCameraFollow(actorSprite.Sprite);
            } 
        }
        else
        {
            var objectSprite = new GameObjectSprite(
                gameObject,
                _manifest.Spec.Sprites,
                _graphics,
                onPointerDown: OnGameObjectPointerDownAsync,
                onPointerOut: OnGameObjectPointerOutAsync,
                onPointerOver: OnGameObjectPointerOverAsync);

            _objectSprites.Add(objectSprite);
        }
    }

    private void RemoveGameObjectsSprites(IEnumerable<GameObject> gameObjects)
    {
        foreach (var gameObject in gameObjects)
        {
            RemoveGameObjectSprite(gameObject);
        }
    }

    private void RemoveGameObjectSprite(GameObject gameObject)
    {
        if (_objectSprites.TryGetValue(
                gameObject.Id,
                out GameObjectSprite objectSprite))
        {
            _logger.LogDebug($"Removing sprite for object '{gameObject.Id}'");

            objectSprite.Dispose();
            _objectSprites.Remove(objectSprite);
        }
    }

    private void OnDraw(Point pointerPosition)
    {
        if (_inDebugMode &&
            _roomSprite is not null &&
            TryGetActorSprite(_protagonistId, out ActorSprite? actorSprite))
        {
            _roomSprite.Room.Walkbox.Draw(
                actorSprite.Sprite.Position,
                pointerPosition,
                GetWalkboxExcludedAreas(_protagonistId),
                _graphics);
        }
    }

    private async Task OnRoomPointerDownAsync(Point pointerPosition)
    {
        if (_playerInputEnabled)
        {
            await MoveActor(_protagonistId, pointerPosition);
        }
    }

    private async Task OnGameObjectPointerDownAsync(
        GameObject gameObject,
        Point mousePosition)
    {
        if (_playerInputEnabled)
        {
            await _mediator.PublishAsync(new GameObjectPointerDown(gameObject));
        }
    }

    private Task OnGameObjectPointerOutAsync(
        GameObject gameObject,
        Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOut(gameObject));

    private Task OnGameObjectPointerOverAsync(
        GameObject gameObject,
        Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOver(gameObject));


    private async Task MoveActor(
        string actorId,
        Point to,
        string status = WellKnownStatus.FaceCamera)
    {
        if (_roomSprite is not null && TryGetActorSprite(
            actorId,
            out ActorSprite? actorSprite))
        {
            var path = _roomSprite.Room.Walkbox.FindShortestPath(
                actorSprite.Sprite.Position,
                to,
                GetWalkboxExcludedAreas(actorId));

            if (_walkState.HasValue)
            {
                _walkState.Value.Cts.Cancel();
                await _walkState.Value.Task;
            }

            var cts = new CancellationTokenSource();
            var task = actorSprite.WalkAsync(path, cts.Token);

            _walkState = (task, cts);

            await task;

            // TODO Set final frame after walk?
            @* actorSprite.Actor.UpdateStatus(status); *@
            actorSprite.ResetSpriteFrame();
        }
    }

    // Exclude the areas around the other actors to make sure the given
    // actor doesn't bump into them.
    private IEnumerable<Polygon> GetWalkboxExcludedAreas(string actorId) =>
        _objectSprites
            .Where(objectSprite => objectSprite is ActorSprite &&
                objectSprite.GameObject.Id != actorId)
            // TODO And actor takes space... IsTransparent???
            .Select(objectSprite =>
            {
                var position = objectSprite.Sprite.Position;

                return new Polygon(new Point[]
                {
                    new Point(position.X - 50, position.Y - 20),
                    new Point(position.X + 50, position.Y - 20),
                    new Point(position.X + 50, position.Y + 20),
                    new Point(position.X - 50, position.Y + 20)
                });
            });

    private bool TryGetActorSprite(
        string id,
        [MaybeNullWhen(false)] out ActorSprite actorSprite)
    {
        if (_objectSprites.TryGetValue(id, out GameObjectSprite objectSprite))
        {
            if (objectSprite is ActorSprite foundActorSprite)
            {
                actorSprite = foundActorSprite;
                return true;
            }
        }

        actorSprite = null;
        return false;
    }
}