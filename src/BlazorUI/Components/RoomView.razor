@inject IMediator _mediator
@inject IJSRuntime _jsRuntime
@inject ILoggerFactory _loggerFactory

<div id="phaser">
</div>

@code {

    private IGraphics _graphics = null!;

    private string _protagonistId = string.Empty;

    private RoomGraphics? _roomGraphics;
    private Dictionary<string, ActorGraphics> _actorGraphicsById = new();
    private Walkbox? _walkbox;

    private (Task Task, CancellationTokenSource Cts)? _talkState;
    private (Task Task, CancellationTokenSource Cts)? _walkState;

    private bool _inDebugMode = false;

    [JSInvokable]
    public bool OnKeyDown(string key)
    {
        switch (key)
        {
            case "d":
                _inDebugMode = !_inDebugMode;
                return true;
            case ".":
            case " ":
                _talkState?.Cts.Cancel();
                return true;
        }

        return false;
    }

    protected override void OnInitialized()
    {
        _mediator.Subscribe<GameManifestLoaded>(OnGameManifestLoaded);
        _mediator.Subscribe<LineSpoken>(OnLineSpoken);
        _mediator.Subscribe<ProtagonistChanged>(OnProtagonistChanged);
        _mediator.Subscribe<RoomEntered>(OnRoomEntered);

        Console.WriteLine("Subscribed!");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await _jsRuntime.InvokeVoidAsync(
                "window.CaptureKeyDown",
                DotNetObjectReference.Create(this));
        }
        base.OnAfterRender(firstRender);
    } 

    private async Task OnGameManifestLoaded(GameManifestLoaded @event)
    {
        var phaser = new PhaserHost(
            @event.Manifest,
            800,
            450,
            (IJSInProcessRuntime)_jsRuntime,
            _loggerFactory,
            OnDraw);

        _graphics = await phaser.StartAsync("phaser");
    }

    private async Task OnLineSpoken(LineSpoken @event)
    {
        if (_actorGraphicsById.TryGetValue(
            @event.Actor.Id,
            out ActorGraphics actorGraphics))
        {
            var cts = new CancellationTokenSource();
            var task = actorGraphics.SpeakAsync(@event.Line, cts.Token);

            _talkState = (task, cts);

            await task;
        }
    }

    public Task OnProtagonistChanged(ProtagonistChanged @event)
    {
        _protagonistId = @event.Protagonist.Id;
        return Task.CompletedTask;
    }

    public async Task OnRoomEntered(RoomEntered @event)
    {
        try
        {
            //    await graphics!.SetRenderLockAsync(true);

            //            //                    if (this.room != null) {
            //            //                        this.room.kill();
            //            //                    }

            _walkbox = new Walkbox(@event.Room.Walkbox);

            _roomGraphics = RoomGraphics.Create(@event.Room, OnRoomPointerDownAsync, _graphics);

            foreach (var actor in @event.Room.Actors)
            {
                var actorGraphics = ActorGraphics.Create(
                    actor,
                    OnGameObjectPointerDownAsync,
                    OnGameObjectPointerOutAsync,
                    OnGameObjectPointerOverAsync,
                    _graphics);


                _actorGraphicsById.Add(actor.Id, actorGraphics);

                // When the protagonist actor is added to the room, follow it
                // with the camera.
                if (actor.Id == _protagonistId)
                {
                    _graphics.StartCameraFollow(actorGraphics.Sprite);
                }
            }

            // TODO Add objects/items


            // Update world bounds to size of room.
            // TODO Actually SetCameraBounds
            _graphics.SetWorldBounds(
                new Size(_roomGraphics.Sprite.Size.Width, _graphics.Height));





            

            //    this.narrator = new Narrator(game, layers);
            //    this.narrator.create();

        }
        finally
        {
            //    await graphics!.SetRenderLockAsync(false);
        }
    }   

    private void OnDraw(Point pointerPosition)
    {
        if (_inDebugMode &&
            _walkbox is not null &&
            _actorGraphicsById.TryGetValue(
                _protagonistId,
                out ActorGraphics? actorGraphics))
        {
            _walkbox.Draw(
                actorGraphics.Sprite.Position,
                pointerPosition,
                GetWalkboxExcludedAreas(_protagonistId),
                _graphics);
        }
    }

    private Task OnRoomPointerDownAsync(Point pointerPosition) =>
        MoveActor(_protagonistId, pointerPosition);

    private Task OnGameObjectPointerDownAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerDown(gameObject));

    private Task OnGameObjectPointerOutAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOut(gameObject));

    private Task OnGameObjectPointerOverAsync(GameObject gameObject, Point mousePosition) =>
        _mediator.PublishAsync(new GameObjectPointerOver(gameObject));


    private async Task MoveActor(string actorId, Point to, Direction faceDirection = Direction.Front)
    {
        if (_walkbox is not null && _actorGraphicsById.TryGetValue(
            actorId,
            out ActorGraphics? actorGraphics))
        {
            var path = _walkbox.FindShortestPath(
                actorGraphics.Sprite.Position,
                to,
                GetWalkboxExcludedAreas(actorId));

            if (_walkState.HasValue)
            {
                _walkState.Value.Cts.Cancel();
                await _walkState.Value.Task;
            }

            var cts = new CancellationTokenSource();
            var task = actorGraphics.WalkAsync(path, faceDirection, cts.Token);

            _walkState = (task, cts);

            await task;
        }
    }

    // Exclude the areas around the other actors to make sure the given
    // actor doesn't bump into them.
    private IEnumerable<Polygon> GetWalkboxExcludedAreas(string actorId) =>
        _actorGraphicsById
            .Where(entry => entry.Key != actorId &&
                entry.Value.Actor.IsVisible)
            .Select(entry =>
            {
                var position = entry.Value.Sprite.Position;

                return new Polygon(
                    new Point(position.X - 50, position.Y - 20),
                    new Point(position.X + 50, position.Y - 20),
                    new Point(position.X + 50, position.Y + 20),
                    new Point(position.X - 50, position.Y + 20));
            });
}